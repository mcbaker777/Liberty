<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>OCM Readiness Map Builder</title>

<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link href="https://fonts.googleapis.com/css2?family=Lora:wght@500;600;700&family=Outfit:wght@300;400;500;600;700&family=Geist+Mono:wght@400;500;600&display=swap" rel="stylesheet" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.2/babel.min.js"></script>

<!-- PDF + DOCX parsing -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.7.2/mammoth.browser.min.js"></script>

<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  :root{
    --navy:#0f172a;
    --navy2:#0b1220;
    --slate:#475569;
    --slate2:#64748b;
    --border:#e2e8f0;
    --off:#f8fafc;
    --off2:#f1f5f9;
    --white:#ffffff;
    --blue:#2563eb;
    --green:#059669;
    --amber:#d97706;
    --orange:#ea580c;
    --red:#dc2626;

    --serif:'Lora', Georgia, serif;
    --sans:'Outfit', system-ui, sans-serif;
    --mono:'Geist Mono', ui-monospace, SFMono-Regular, Menlo, monospace;

    --shadow-sm:0 1px 3px rgba(0,0,0,.06),0 1px 2px rgba(0,0,0,.04);
    --shadow-md:0 6px 18px rgba(0,0,0,.12),0 2px 8px rgba(0,0,0,.06);
    --shadow-lg:0 14px 40px rgba(0,0,0,.18),0 6px 18px rgba(0,0,0,.10);

    --radius:12px;
    --glow-blue:0 0 0 3px rgba(37,99,235,.15);
  }
  html, body, #root { height:100%; }
  body{
    font-family:var(--sans);
    font-size:15px;
    background:var(--off);
    color:var(--navy);
  }

  ::-webkit-scrollbar{width:6px;height:6px;}
  ::-webkit-scrollbar-track{background:transparent;}
  ::-webkit-scrollbar-thumb{background:#cbd5e1;border-radius:999px;}
  ::-webkit-scrollbar-thumb:hover{background:#94a3b8;}

  /* Top bar */
  .appTopBar{
    background:linear-gradient(180deg,var(--navy) 0%, var(--navy2) 100%);
    color:#e2e8f0;
    border-bottom:1px solid rgba(255,255,255,.08);
    padding:12px 16px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
  }
  .subtle{ color:#94a3b8; }

  /* Controls */
  .btn{
    border:none;
    cursor:pointer;
    font-family:var(--sans);
    font-weight:800;
    padding:9px 12px;
    border-radius:12px;
    display:inline-flex;
    align-items:center;
    gap:8px;
    transition:transform .08s ease, box-shadow .14s ease, background .14s ease, color .14s ease, opacity .14s ease;
    user-select:none;
    line-height:1;
  }
  .btn:active{ transform:translateY(1px); }
  .btn-primary{ background:var(--blue); color:#fff; box-shadow:var(--shadow-sm); }
  .btn-primary:hover{ box-shadow:var(--shadow-md); }
  .btn-secondary{ background:#fff; color:var(--navy); border:1px solid var(--border); }
  .btn-secondary:hover{ background:var(--off2); }
  .btn-ghost{ background:transparent; color:var(--navy); border:1px solid transparent; }
  .btn-ghost:hover{ background:var(--off2); }
  .btn-danger{ background:#fff; color:var(--red); border:1px solid #fecaca; }
  .btn-danger:hover{ background:#fff1f2; }

  .btn-dark-ghost{ background:transparent; color:#e2e8f0; border:1px solid rgba(226,232,240,.18); }
  .btn-dark-ghost:hover{ background:rgba(255,255,255,.06); }
  .btn-dark-chip{ background:rgba(255,255,255,.06); color:#e2e8f0; border:1px solid rgba(226,232,240,.18); }

  .inp{
    width:100%;
    border-radius:12px;
    border:1px solid var(--border);
    padding:10px 12px;
    background:#fff;
    color:var(--navy);
    outline:none;
    font-family:var(--sans);
    transition:box-shadow .14s ease, border-color .14s ease;
  }
  .inp:focus{ box-shadow:var(--glow-blue); border-color:rgba(37,99,235,.55); }
  textarea.inp{ min-height:120px; resize:vertical; line-height:1.5; }

  .lbl{
    display:block;
    font-size:12px;
    font-weight:900;
    letter-spacing:.08em;
    font-family:var(--mono);
    color:var(--slate2);
    margin-bottom:8px;
    text-transform:uppercase;
  }

  .card{
    background:#fff;
    border:1px solid var(--border);
    border-radius:16px;
    box-shadow:var(--shadow-sm);
  }
  .pill{
    display:inline-flex;
    align-items:center;
    gap:6px;
    border:1px solid var(--border);
    padding:7px 10px;
    border-radius:999px;
    font-size:12px;
    font-family:var(--mono);
    font-weight:800;
    color:#334155;
    background:#fff;
  }

  /* Dropdown menu */
  .menu{
    position:absolute;
    right:0;
    top:34px;
    min-width:220px;
    padding:8px;
    border-radius:12px;
    background:#fff;
    border:1px solid var(--border);
    box-shadow:var(--shadow-lg);
    z-index:1000;
    animation:scaleIn .14s ease both;
  }
  .menu button{
    width:100%;
    text-align:left;
    background:transparent;
    border:none;
    border-radius:10px;
    padding:10px 10px;
    cursor:pointer;
    font-family:var(--sans);
    font-weight:800;
    color:#334155;
  }
  .menu button:hover{ background:var(--off2); }
  .menu .danger{ color:var(--red); }

  @keyframes scaleIn{ from{ transform:translateY(-4px) scale(.98); opacity:0; } to{ transform:translateY(0) scale(1); opacity:1; } }
  @keyframes fadeIn{ from{ opacity:0; } to{ opacity:1; } }
  @keyframes spin{ to{ transform:rotate(360deg);} }
  .fade-up{ animation:fadeUp .18s ease both; }
  @keyframes fadeUp{ from{ transform:translateY(6px); opacity:0; } to{ transform:translateY(0); opacity:1; } }

  /* Overlay */
  .overlay{
    position:fixed;
    inset:0;
    z-index:10000;
    background:rgba(255,255,255,.72);
    backdrop-filter: blur(4px);
    display:flex;
    align-items:center;
    justify-content:center;
    animation:fadeIn .15s ease both;
  }
  .overlayCard{
    background:#fff;
    border:1px solid var(--border);
    border-radius:16px;
    padding:18px 18px;
    box-shadow:var(--shadow-lg);
    min-width:280px;
    max-width:520px;
  }

  /* ===== Stage 4 layout ===== */
  .stage4Shell{
    display:flex;
    height:100%;
    min-height:0;
    background:var(--off);
  }

  /* Left sidebar */
  .leftSide{
    width:320px;
    border-right:1px solid var(--border);
    background:#0b1220;
    color:#e2e8f0;
    display:flex;
    flex-direction:column;
    min-width:0;
  }
  .leftSide.rail{
    width:58px;
  }
  .leftSideHeader{
    padding:12px 12px;
    border-bottom:1px solid rgba(226,232,240,.14);
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:8px;
  }
  .leftTabs{
    display:flex;
    border-bottom:1px solid rgba(226,232,240,.14);
  }

  .leftRailIcon{
    width:42px;height:42px;border-radius:12px;
    display:flex;align-items:center;justify-content:center;
    border:1px solid rgba(226,232,240,.14);
    background:rgba(255,255,255,.04);
    cursor:pointer;
  }
  .leftRailIcon:hover{ background:rgba(255,255,255,.07); }

  /* Main area */
  .mainArea{
    flex:1;
    min-width:0;
    display:flex;
    flex-direction:column;
  }

  /* Grid scroll region */
  .gridWrap{
    flex:1;
    min-height:0;
    overflow:auto;
    padding:14px;
  }
  .mapGrid{
    display:grid;
    gap:10px;
    align-items:stretch;
  }
  .phaseHeaderCell{ overflow:visible; position:relative; }
  .phaseCell{
    position:relative;
    min-width:260px;
    overflow:visible;
    z-index:1; /* below sticky column */
  }
  .phaseStripe{ background:#f8fafc; }

  /* Sticky Workstream column (no bleed) */
  .laneHeaderCell{
    position:sticky;
    left:0;
    z-index:200;
    background:#fff;
    background-clip:padding-box;
    isolation:isolate;
    box-shadow:2px 0 10px rgba(0,0,0,.06);
  }
  .laneHeaderCell::after{
    content:"";
    position:absolute;
    top:0;
    right:-10px;
    width:10px;
    height:100%;
    pointer-events:none;
    background:linear-gradient(to right, rgba(0,0,0,.08), rgba(0,0,0,0));
  }

  /* Lane tile */
  .laneTile{
    position:relative;
    padding:10px 10px 10px 12px;
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    gap:10px;
  }
  .laneBar{
    position:absolute;
    left:0; top:0; bottom:0;
    width:5px;
    border-top-left-radius:16px;
    border-bottom-left-radius:16px;
  }
  .iconBtn{
    width:30px;height:30px;border-radius:10px;
    border:1px solid var(--border);
    background:#fff;
    cursor:pointer;
    display:flex;align-items:center;justify-content:center;
    font-weight:900;
    transition:background .14s ease, box-shadow .14s ease;
  }
  .iconBtn:hover{ background:var(--off2); box-shadow:var(--shadow-sm); }
  .iconBtn.danger{ border-color:#fecaca; color:var(--red); }
  .iconBtn.danger:hover{ background:#fff1f2; }

  /* Task card */
  .taskCard{
    position:relative;
    background:#fff;
    border:1px solid var(--border);
    border-radius:12px;
    box-shadow:var(--shadow-sm);
    transition:transform .14s ease, box-shadow .14s ease, opacity .14s ease;
    cursor:pointer;
    overflow:hidden;
  }
  .taskCard:hover{ transform:translateY(-1px); box-shadow:var(--shadow-md); }
  .taskBorder{
    position:absolute; left:0; top:0; bottom:0;
    width:5px;
  }
  .taskInner{ padding:10px 10px 10px 12px; display:flex; flex-direction:column; gap:6px; }
  .taskTitle{ font-weight:900; font-size:13px; color:var(--navy); }
  .taskMeta{ font-size:12px; color:var(--slate2); font-family:var(--mono); }
  .taskRisk{ font-size:11px; font-family:var(--mono); font-weight:900; color:#b45309; }

  /* Right drawer */
  .drawer{
    width:420px;
    border-left:1px solid var(--border);
    background:#f3f4f6;
    box-shadow:inset 8px 0 18px rgba(0,0,0,.05);
    display:flex;
    flex-direction:column;
    min-width:0;
  }
  .drawer.rail{ width:58px; }
  .drawerHeader{
    padding:12px 12px;
    border-bottom:1px solid rgba(15,23,42,.08);
    display:flex; align-items:center; justify-content:space-between; gap:8px;
  }
  .drawerBody{
    padding:12px;
    overflow:auto;
    min-height:0;
  }

  /* Phase date popover */
  .pop{
    position:absolute;
    top:44px;
    right:10px;
    width:260px;
    padding:10px;
    border-radius:14px;
    background:#fff;
    border:1px solid var(--border);
    box-shadow:var(--shadow-lg);
    z-index:1200;
  }

  /* Small checkbox */
  .chk{
    width:18px;height:18px;
    accent-color:var(--blue);
    cursor:pointer;
  }

  /* Sidebar lane row (workstreams tab) */
  .laneRow{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    padding:10px 10px;
    border-left:5px solid #64748b;
  }
  .laneRowRight{ display:flex; align-items:center; gap:8px; }

</style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
const {useEffect,useMemo,useRef,useState} = React;

/* ===== Click Audio (optional) ===== */
const ClickAudio = (() => {
  let enabled = true;
  let ctx = null;
  function ensure(){
    if(!ctx){
      const AC = window.AudioContext || window.webkitAudioContext;
      if(!AC) return null;
      ctx = new AC();
    }
    return ctx;
  }
  function click(){
    if(!enabled) return;
    const c = ensure();
    if(!c) return;
    const o = c.createOscillator();
    const g = c.createGain();
    o.type = "square";
    o.frequency.value = 680;
    g.gain.value = 0.02;
    o.connect(g); g.connect(c.destination);
    o.start();
    setTimeout(()=>{ try{o.stop();}catch(_){} }, 26);
  }
  return {
    click,
    setEnabled:(v)=>{ enabled = !!v; },
    isEnabled:()=>enabled
  };
})();

/* ===== Constants ===== */
const LANE_PALETTE = ["#2563eb","#0d9488","#7c3aed","#dc2626","#d97706","#059669","#0ea5e9","#9333ea","#475569"];
const STATUS_META = {
  complete:{label:"COMPLETE", color:"#059669"},
  green:{label:"ON TRACK", color:"#059669"},
  blue:{label:"IN PROGRESS", color:"#2563eb"},
  amber:{label:"WATCH", color:"#d97706"},
  orange:{label:"AT RISK", color:"#ea580c"},
  red:{label:"CRITICAL", color:"#dc2626"},
  blocked:{label:"BLOCKED", color:"#b91c1c"},
};
const DIMENSIONS = [
  {id:"scope", label:"Scope & Complexity", opts:[{v:1,l:"Low"},{v:2,l:"Medium"},{v:3,l:"High",esc:true}]},
  {id:"impact", label:"Business Impact", opts:[{v:1,l:"Low"},{v:2,l:"Medium"},{v:3,l:"High",esc:true}]},
  {id:"audience", label:"Audience Size", opts:[{v:1,l:"Small"},{v:2,l:"Moderate"},{v:3,l:"Large"}]},
  {id:"readiness", label:"Current Readiness", opts:[{v:1,l:"High"},{v:2,l:"Mixed"},{v:3,l:"Low"}]},
  {id:"risk", label:"Change Risk", opts:[{v:1,l:"Low"},{v:2,l:"Medium"},{v:3,l:"High",esc:true}]},
];
const TIER_CFG = {
  1:{label:"Tier 1",sub:"High Complexity / Broad Impact",color:"#dc2626",bg:"#fff1f2",bdr:"#fecaca",
     desc:"Full OCM program with dedicated planning, multi-channel communications, training strategy, readiness/risk management, and adoption reinforcement.",
     phases:["Targeting","Mobilization","Readiness","Day-1 / Go-Live","Stabilization","TSA / Sustainment"],
     lanes:["Stakeholder & Comms","Training & Enablement","Readiness & Risk","Technical / Systems","Leadership & Sponsorship"],
     deliverables:["Stakeholder Map","Change Impact Analysis","Full OCM Plan","Comms Strategy","Training Program","Readiness Assessments","Adoption Metrics","Resistance Management","Lessons Learned"],
     statuses:["complete","green","blue","amber","orange","red","blocked"]},
  2:{label:"Tier 2",sub:"Moderate Complexity / Targeted Impact",color:"#0d9488",bg:"#f0fdfa",bdr:"#99f6e4",
     desc:"Targeted OCM support at key milestones ‚Äî readiness assessment, key communications, training deliverables, and stakeholder engagement.",
     phases:["Planning","Execution","Go-Live","Sustainment"],
     lanes:["Stakeholder & Comms","Training & Enablement","Readiness & Risk"],
     deliverables:["Lightweight CM Plan","Stakeholder List","Comms Plan","Training Summary","Pulse Checks","Lessons Learned"],
     statuses:["complete","green","blue","amber","orange","red","blocked"]},
  3:{label:"Tier 3",sub:"Low Complexity / Limited Impact",color:"#64748b",bg:"#f8fafc",bdr:"#e2e8f0",
     desc:"Light-touch support ‚Äî self-service materials, templates, and optional PM-led communications with OCM check-in as needed.",
     phases:["Setup","Delivery","Close"],
     lanes:["Key Actions"],
     deliverables:["Stakeholder Notification","Quick Reference Guide","Go/No-Go Checklist"],
     statuses:["complete","green","blue","amber","orange","red","blocked"]},
};

function getTier(sc){
  const total = Object.values(sc).reduce((a,b)=>a+b,0);
  const esc = DIMENSIONS.some(d => d.opts.find(o=>o.v===sc[d.id])?.esc);
  return (esc || total>=20) ? 1 : (total>=14 ? 2 : 3);
}

/* ===== Anthropic Call (optional) ===== */
async function callClaude(userMsg, apiKey){
  const res = await fetch("https://api.anthropic.com/v1/messages",{
    method:"POST",
    headers:{
      "Content-Type":"application/json",
      "x-api-key": apiKey,
      "anthropic-version": "2023-06-01",
      "anthropic-dangerous-direct-browser-access": "true"
    },
    body: JSON.stringify({
      model:"claude-sonnet-4-5",
      max_tokens:1500,
      system:"You are an expert OCM strategist. Return ONLY valid JSON ‚Äî no markdown, no explanation, no backticks.",
      messages:[{role:"user",content:userMsg}]
    })
  });
  if(!res.ok){
    const e = await res.json().catch(()=>({}));
    throw new Error(e?.error?.message || `HTTP ${res.status}`);
  }
  const data = await res.json();
  const raw = (data.content||[]).map(c=>c.text||"").join("").trim();
  const clean = raw.replace(/^```json\s*/,"").replace(/^```\s*/,"").replace(/\s*```$/,"").trim();
  return JSON.parse(clean);
}

/* ===== Utilities ===== */
function getTaskId(lane, phase, idx){ return `${lane}||${phase}||${idx}`; }
function parseTaskId(id){
  const [lane,phase,idx] = String(id||"").split("||");
  return {lane,phase,idx:Number(idx)};
}
function deepClone(x){ return JSON.parse(JSON.stringify(x)); }

/* ===== PDF/DOCX Text Extraction ===== */
async function extractTextFromFile(file){
  const ext = (file.name.split(".").pop() || "").toLowerCase();
  const mime = (file.type || "").toLowerCase();
  const MAX = 2000;

  if(ext==="pdf" || mime==="application/pdf"){
    try{
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.worker.min.js";
    }catch(_){}
    const buf = await file.arrayBuffer();
    const doc = await pdfjsLib.getDocument({data: buf}).promise;

    let out = "";
    const pagesToRead = Math.min(2, doc.numPages);
    for(let p=1; p<=pagesToRead; p++){
      const page = await doc.getPage(p);
      const content = await page.getTextContent();
      const strings = content.items.map(it => it.str).filter(Boolean);
      out += strings.join(" ") + "\n";
      if(out.length >= MAX) break;
    }
    return out.slice(0, MAX).trim();
  }

  if(ext==="docx" || mime==="application/vnd.openxmlformats-officedocument.wordprocessingml.document"){
    const buf = await file.arrayBuffer();
    const res = await mammoth.extractRawText({arrayBuffer: buf});
    const txt = (res?.value || "").replace(/\s+\n/g,"\n").trim();
    return txt.slice(0, MAX);
  }

  const text = await file.text();
  return String(text || "").slice(0, MAX).trim();
}

/* ===== Steps UI ===== */
function Steps({current}){
  const steps=["Project Info","Tiering","Configure","Build Map"];
  return(
    <div style={{display:"flex",alignItems:"center",marginBottom:28}}>
      {steps.map((s,i)=>{
        const done=i<current, active=i===current;
        return(
          <React.Fragment key={i}>
            <div style={{display:"flex",flexDirection:"column",alignItems:"center",gap:6}}>
              <div style={{
                width:34,height:34,borderRadius:"50%",
                display:"flex",alignItems:"center",justifyContent:"center",
                fontSize:13,fontWeight:900,
                background:done?"#059669":active?"#2563eb":"#fff",
                border:`2px solid ${done?"#059669":active?"#2563eb":"#e2e8f0"}`,
                color:(done||active)?"#fff":"#94a3b8"
              }}>{done?"‚úì":i+1}</div>
              <div style={{fontSize:13,fontWeight:active?900:700,color:active?"#2563eb":done?"#059669":"#94a3b8",whiteSpace:"nowrap"}}>
                {s}
              </div>
            </div>
            {i<steps.length-1 && (
              <div style={{flex:1,height:2,margin:"0 10px",marginBottom:22,background:done?"#059669":"#e2e8f0"}}/>
            )}
          </React.Fragment>
        );
      })}
    </div>
  );
}

/* ===== Stage 1 ===== */
function Stage1({onNext}){
  const [f,setF]=useState({name:"",owner:"",date:"",description:""});
  const [inputMode,setInputMode]=useState("text");
  const [uploadedFileName,setUploadedFileName]=useState("");
  const [uploadBusy,setUploadBusy]=useState(false);
  const [uploadErr,setUploadErr]=useState(null);

  const ok = f.name.trim() && f.description.trim();
  const set = k => e => setF(p=>({...p,[k]:e.target.value}));

  const handleFile = async (e)=>{
    const file=e.target.files?.[0];
    if(!file) return;
    setUploadedFileName(file.name);
    setUploadErr(null);
    setUploadBusy(true);
    try{
      const extracted = await extractTextFromFile(file);
      setF(p=>({...p,description: extracted || p.description}));
    }catch(err){
      setUploadErr(`Could not read file: ${err?.message || "Unknown error"}.`);
    }finally{
      setUploadBusy(false);
      e.target.value="";
    }
  };

  return(
    <div className="fade-up">
      <h2 style={{fontFamily:"var(--serif)",fontSize:28,marginBottom:6}}>Tell us about your initiative</h2>
      <p style={{fontSize:15,color:"var(--slate)",marginBottom:22,lineHeight:1.6}}>
        This anchors the readiness map and informs AI-generated content.
      </p>

      <div style={{display:"grid",gridTemplateColumns:"1fr 1fr",gap:14,marginBottom:14}}>
        <div>
          <label className="lbl">Initiative / Project Name *</label>
          <input className="inp" placeholder="e.g. Project Awesome Sauce" value={f.name} onChange={set("name")} />
        </div>
        <div>
          <label className="lbl">OCM Lead / Owner</label>
          <input className="inp" placeholder="e.g. John Doe" value={f.owner} onChange={set("owner")} />
        </div>
        <div>
          <label className="lbl">Target Go-Live Date</label>
          <input className="inp" type="date" value={f.date} onChange={set("date")} />
        </div>
      </div>

      <div style={{marginBottom:18}}>
        <div style={{display:"flex",alignItems:"center",justifyContent:"space-between",marginBottom:8}}>
          <label className="lbl" style={{marginBottom:0}}>Brief Initiative Description *</label>
          <div style={{display:"flex",gap:2,background:"var(--off2)",borderRadius:12,padding:2}}>
            <button
              onClick={()=>setInputMode("text")}
              style={{
                fontSize:11,fontWeight:900,fontFamily:"var(--mono)",
                padding:"6px 10px",borderRadius:10,border:"none",cursor:"pointer",
                background:inputMode==="text"?"#fff":"transparent",
                color:inputMode==="text"?"var(--navy)":"var(--slate)",
                boxShadow:inputMode==="text"?"var(--shadow-sm)":"none"
              }}
            >‚úè Type</button>
            <button
              onClick={()=>setInputMode("upload")}
              style={{
                fontSize:11,fontWeight:900,fontFamily:"var(--mono)",
                padding:"6px 10px",borderRadius:10,border:"none",cursor:"pointer",
                background:inputMode==="upload"?"#fff":"transparent",
                color:inputMode==="upload"?"var(--navy)":"var(--slate)",
                boxShadow:inputMode==="upload"?"var(--shadow-sm)":"none"
              }}
            >‚Üë Upload Doc</button>
          </div>
        </div>

        {inputMode==="text" ? (
          <textarea className="inp"
            placeholder="What is changing? Who is affected? What does success look like?"
            value={f.description}
            onChange={set("description")}
          />
        ) : (
          <div className="card" style={{padding:14}}>
            <div style={{display:"flex",alignItems:"center",justifyContent:"space-between",gap:12}}>
              <div style={{minWidth:0}}>
                <div style={{fontWeight:900}}>Upload a PDF or DOCX</div>
                <div style={{fontSize:13,color:"var(--slate)",marginTop:4,lineHeight:1.6}}>
                  We extract up to ~2 pages of text to prefill your description.
                </div>
                {uploadedFileName && (
                  <div style={{marginTop:8,fontFamily:"var(--mono)",fontSize:12,color:"var(--slate2)"}}>
                    File: {uploadedFileName}
                  </div>
                )}
              </div>
              <label className="btn btn-secondary" style={{cursor:uploadBusy?"not-allowed":"pointer",opacity:uploadBusy?.8:1}}>
                {uploadBusy ? "Reading‚Ä¶" : "Choose File"}
                <input type="file" accept=".pdf,.docx,.txt" onChange={handleFile} style={{display:"none"}} disabled={uploadBusy}/>
              </label>
            </div>
            {uploadErr && (
              <div style={{marginTop:12,color:"var(--red)",fontWeight:800}}>
                {uploadErr}
              </div>
            )}
          </div>
        )}
      </div>

      <div style={{display:"flex",justifyContent:"flex-end"}}>
        <button className="btn btn-primary" disabled={!ok} onClick={()=>{ClickAudio.click(); onNext(f);}}>
          Continue ‚Üí
        </button>
      </div>
    </div>
  );
}

/* ===== Stage 2 ===== */
function Stage2({project,onNext}){
  const [sc,setSc]=useState(()=>Object.fromEntries(DIMENSIONS.map(d=>[d.id,2])));
  const tier = useMemo(()=>getTier(sc),[sc]);
  const cfg = TIER_CFG[tier];
  const done = true;

  return(
    <div className="fade-up">
      <h2 style={{fontFamily:"var(--serif)",fontSize:28,marginBottom:6}}>Tiering</h2>
      <p style={{fontSize:15,color:"var(--slate)",marginBottom:18,lineHeight:1.6}}>
        Answer a few questions to recommend an OCM support tier.
      </p>

      <div style={{display:"grid",gridTemplateColumns:"1fr 1fr",gap:14,marginBottom:14}}>
        {DIMENSIONS.map(d=>(
          <div key={d.id} className="card" style={{padding:14}}>
            <div style={{fontWeight:900,marginBottom:10}}>{d.label}</div>
            <div style={{display:"flex",gap:10}}>
              {d.opts.map(o=>(
                <button key={o.v} className="btn"
                  onClick={()=>{ClickAudio.click(); setSc(p=>({...p,[d.id]:o.v}));}}
                  style={{
                    flex:1,
                    padding:"10px 10px",
                    borderRadius:12,
                    background: sc[d.id]===o.v ? "#eff6ff" : "#fff",
                    border: sc[d.id]===o.v ? "1px solid rgba(37,99,235,.45)" : "1px solid var(--border)",
                    color: sc[d.id]===o.v ? "#2563eb" : "#334155",
                    boxShadow: sc[d.id]===o.v ? "0 0 0 3px rgba(37,99,235,.10)" : "none"
                  }}>
                  <span style={{fontFamily:"var(--mono)",fontSize:12,fontWeight:900}}>{o.l}</span>
                </button>
              ))}
            </div>
          </div>
        ))}
      </div>

      <div className="card" style={{padding:"14px 16px",marginBottom:14,background:cfg.bg,borderColor:cfg.bdr}}>
        <div style={{fontFamily:"var(--mono)",fontSize:12,fontWeight:900,letterSpacing:".08em",color:cfg.color,marginBottom:10}}>
          RECOMMENDED: {cfg.label} ¬∑ {cfg.sub}
        </div>
        <div style={{display:"flex",gap:12,alignItems:"flex-start"}}>
          <div style={{fontSize:20}}>{tier===1?"üî¥":tier===2?"üü°":"üü¢"}</div>
          <div style={{fontSize:14,color:"var(--slate)",lineHeight:1.7}}>
            {cfg.desc}
          </div>
        </div>
      </div>

      <div style={{display:"flex",justifyContent:"flex-end"}}>
        <button className="btn btn-primary" disabled={!done} onClick={()=>{ClickAudio.click(); onNext(sc,tier);}}>
          Review &amp; Configure Map ‚Üí
        </button>
      </div>
    </div>
  );
}

/* ===== Stage 3 ===== */
function Stage3({project,suggestedTier,apiKey,onNext}){
  const [tier,setTier]=useState(suggestedTier);
  const [override,setOverride]=useState("");
  const [lanes,setLanes]=useState(TIER_CFG[suggestedTier].lanes.join("\n"));
  const [phases,setPhases]=useState(TIER_CFG[suggestedTier].phases.join("\n"));
  const [gen,setGen]=useState(false);
  const [err,setErr]=useState(null);
  const cfg=TIER_CFG[tier];

  const laneArr=useMemo(()=>lanes.split("\n").map(s=>s.trim()).filter(Boolean),[lanes]);
  const phaseArr=useMemo(()=>phases.split("\n").map(s=>s.trim()).filter(Boolean),[phases]);

  const changeTier=t=>{
    ClickAudio.click();
    setTier(t);
    setLanes(TIER_CFG[t].lanes.join("\n"));
    setPhases(TIER_CFG[t].phases.join("\n"));
  };

  const emptyTasks=()=>{
    const t={};
    laneArr.forEach(l=>{ t[l]={}; phaseArr.forEach(p=>{ t[l][p]=[]; }); });
    return t;
  };

  const generate=async()=>{
    if(!apiKey.trim()){
      setErr("Please enter your Anthropic API key in the top bar before generating.");
      return;
    }
    ClickAudio.click();
    setGen(true); setErr(null);
    try{
      const prompt=`Generate a readiness map for this OCM initiative.
Name: ${project.name}
Description: ${project.description}
Tier: ${tier} (${cfg.sub})
Phases: ${phaseArr.join(", ")}
Lanes (workstreams): ${laneArr.join(", ")}
Return ONLY this JSON structure, nothing else:
{"tasks":{"LANE_NAME":{"PHASE_NAME":[{"label":"short task name under 6 words","status":"blue","detail":"2-3 sentence description of this task and what completion looks like.","owner":"","links":[],"blocks":[],"blockedBy":[]}]}}}
Important rules:
- Replace LANE_NAME with actual lane names from the list above
- Replace PHASE_NAME with actual phase names from the list above
- status must be one of: ${cfg.statuses.join(", ")}
- Include 1-3 tasks per lane per phase
- Tasks must be realistic OCM activities for a ${cfg.sub} initiative`;
      const result=await callClaude(prompt, apiKey);
      setGen(false);
      onNext(tier,laneArr,phaseArr,result.tasks,override,true);
    }catch(e){
      setGen(false);
      setErr(`Generation failed: ${e.message}. You can start with an empty map and add tasks manually.`);
    }
  };

  return(
    <div className="fade-up">
      <h2 style={{fontFamily:"var(--serif)",fontSize:28,marginBottom:6}}>Configure</h2>
      <p style={{fontSize:15,color:"var(--slate)",marginBottom:18,lineHeight:1.6}}>
        Confirm the tier, phases, and workstreams ‚Äî then generate tasks with AI or start empty.
      </p>

      <div className="card" style={{padding:"14px 16px",marginBottom:14}}>
        <div style={{display:"flex",alignItems:"center",justifyContent:"space-between",gap:10}}>
          <div>
            <div className="lbl" style={{marginBottom:6}}>Support Tier</div>
            <div style={{fontWeight:900, fontSize:16}}>{cfg.label} ¬∑ {cfg.sub}</div>
          </div>
          <div style={{display:"flex",gap:8}}>
            {[1,2,3].map(t=>(
              <button key={t} className="btn"
                onClick={()=>changeTier(t)}
                style={{
                  background: tier===t ? "#eff6ff" : "#fff",
                  border: tier===t ? "1px solid rgba(37,99,235,.45)" : "1px solid var(--border)",
                  color: tier===t ? "#2563eb" : "#334155"
                }}
              >
                {TIER_CFG[t].label}
              </button>
            ))}
          </div>
        </div>

        {tier!==suggestedTier && (
          <div style={{marginTop:12}}>
            <label className="lbl">Override rationale</label>
            <input className="inp" value={override} onChange={e=>setOverride(e.target.value)}
              placeholder="Why are you changing from the suggested tier?" />
          </div>
        )}
      </div>

      <div style={{display:"grid",gridTemplateColumns:"1fr 1fr",gap:14,marginBottom:14}}>
        <div>
          <label className="lbl">Map Lanes (one per line)</label>
          <textarea className="inp" style={{minHeight:120}} value={lanes} onChange={e=>setLanes(e.target.value)} />
          <div style={{fontSize:13,color:"var(--slate)",marginTop:6}}>Default: {cfg.lanes.join(", ")}</div>
        </div>
        <div>
          <label className="lbl">Map Phases (one per line)</label>
          <textarea className="inp" style={{minHeight:120}} value={phases} onChange={e=>setPhases(e.target.value)} />
          <div style={{fontSize:13,color:"var(--slate)",marginTop:6}}>Default: {cfg.phases.join(", ")}</div>
        </div>
      </div>

      <div className="card" style={{padding:"14px 16px",marginBottom:14,background:cfg.bg,borderColor:cfg.bdr}}>
        <div style={{fontSize:12,fontWeight:900,letterSpacing:".08em",color:cfg.color,fontFamily:"var(--mono)",marginBottom:10}}>
          REQUIRED DELIVERABLES
        </div>
        <div style={{display:"flex",flexWrap:"wrap",gap:8}}>
          {cfg.deliverables.map(d=>(
            <span key={d} className="pill" style={{borderColor:cfg.bdr,color:cfg.color}}>
              {d}
            </span>
          ))}
        </div>
      </div>

      {err && (
        <div className="card" style={{padding:"12px 14px",borderColor:"#fecaca",background:"#fff1f2",color:"var(--red)",marginBottom:12}}>
          {err}
        </div>
      )}

      <div style={{display:"flex",justifyContent:"space-between",alignItems:"center"}}>
        <button className="btn btn-secondary" disabled={gen || !laneArr.length || !phaseArr.length}
          onClick={()=>{ClickAudio.click(); onNext(tier,laneArr,phaseArr,emptyTasks(),override,false);}}>
          Start with Empty Map
        </button>

        <button className="btn btn-primary" disabled={gen || !laneArr.length || !phaseArr.length} onClick={generate}>
          {gen ? (
            <>
              <span style={{width:14,height:14,border:"2px solid rgba(255,255,255,.5)",borderTopColor:"#fff",borderRadius:"50%",display:"inline-block",animation:"spin .7s linear infinite"}}></span>
              Generating‚Ä¶
            </>
          ) : (
            <>‚ú¶ Generate Map with AI ‚Üí</>
          )}
        </button>
      </div>
    </div>
  );
}
/* ===== Dependency Graph Utilities ===== */

function buildDependencyIndex(tasks){
  const index = {};
  Object.entries(tasks).forEach(([lane,phases])=>{
    Object.entries(phases).forEach(([phase,arr])=>{
      arr.forEach((task,i)=>{
        const id = getTaskId(lane,phase,i);
        index[id] = task;
      });
    });
  });
  return index;
}

function getUpstreamChain(taskId, tasks){
  const index = buildDependencyIndex(tasks);
  const visited = new Set();
  const result = [];

  function walk(id){
    if(visited.has(id)) return;
    visited.add(id);
    const t = index[id];
    if(!t) return;
    (t.blockedBy||[]).forEach(dep=>{
      result.push(dep);
      walk(dep);
    });
  }

  walk(taskId);
  return result;
}

function getDownstreamChain(taskId, tasks){
  const index = buildDependencyIndex(tasks);
  const visited = new Set();
  const result = [];

  function walk(id){
    if(visited.has(id)) return;
    visited.add(id);
    const t = index[id];
    if(!t) return;
    (t.blocks||[]).forEach(dep=>{
      result.push(dep);
      walk(dep);
    });
  }

  walk(taskId);
  return result;
}

/* ===== Stage 4 ===== */

  function deleteLane(name){
    if(!confirm(`Delete workstream "${name}"?`)) return;

    setLaneList(p=>p.filter(l=>l.name!==name));

    setTasks(p=>{
      const clone = deepClone(p);
      delete clone[name];
      return clone;
    });
  }

  function renameLane(oldName,newName){
    if(!newName.trim()) return;
    if(oldName===newName) return;

    setLaneList(p=>p.map(l=>l.name===oldName?{...l,name:newName}:l));

    setTasks(p=>{
      const clone = {};
      Object.entries(p).forEach(([lane,ph])=>{
        clone[lane===oldName?newName:lane]=ph;
      });
      return clone;
    });
  }

  function toggleLaneVisibility(name){
    setLaneList(p=>p.map(l=>l.name===name?{...l,visible:!l.visible}:l));
  }

  function toggleLaneCollapse(name){
    setLaneList(p=>p.map(l=>l.name===name?{...l,collapsed:!l.collapsed}:l));
  }

  /* ===== Task Operations ===== */

  function addTask(lane,phase){
    setTasks(p=>{
      const clone = deepClone(p);
      clone[lane][phase].push({
        label:"New Task",
        status:"blue",
        detail:"",
        owner:"",
        blocks:[],
        blockedBy:[]
      });
      return clone;
    });
  }

  function updateTask(lane,phase,index,updates){
    setTasks(p=>{
      const clone = deepClone(p);
      clone[lane][phase][index]={...clone[lane][phase][index],...updates};
      return clone;
    });
  }

  function deleteTask(lane,phase,index){
    setTasks(p=>{
      const clone = deepClone(p);
      const id = getTaskId(lane,phase,index);

      clone[lane][phase].splice(index,1);

      Object.values(clone).forEach(phases=>{
        Object.values(phases).forEach(arr=>{
          arr.forEach(task=>{
            task.blocks = (task.blocks||[]).filter(b=>b!==id);
            task.blockedBy = (task.blockedBy||[]).filter(b=>b!==id);
          });
        });
      });

      return clone;
    });

    setSelectedTask(null);
  }

  /* ===== Phase Date Update ===== */

  function updatePhaseDate(phaseName, field, value){
    setPhaseList(p=>p.map(ph=>ph.name===phaseName?{...ph,[field]:value}:ph));
  }

  /* ===== Import / Export ===== */

  function exportJSON(){
    const data = {
      project,
      tier,
      lanes:laneList,
      phases:phaseList,
      tasks
    };
    const blob = new Blob([JSON.stringify(data,null,2)],{type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href=url;
    a.download=`${project.name || "ocm-map"}.json`;
    a.click();
    URL.revokeObjectURL(url);
  }

  function importJSON(file){
    const reader = new FileReader();
    reader.onload=e=>{
      try{
        const data = JSON.parse(e.target.result);
        setLaneList(data.lanes || []);
        setPhaseList(data.phases || []);
        setTasks(data.tasks || {});
      }catch(err){
        alert("Invalid JSON file.");
      }
    };
    reader.readAsText(file);
  }

  /* ===== Derived ===== */

  const visibleLanes = laneList.filter(l=>l.visible);

  /* ===== UI Render (Grid + Sidebars in Part 3) ===== */

  return (
    <div className="stage4Shell">
      {/* Left Sidebar + Main + Drawer defined in Part 3 */}
    </div>
  );
}
 
/* =========================================================
   Stage 4 FIXED (integrated, stable, dependency-safe)
   ========================================================= */

function Stage4Fixed({
  project,
  tier,
  lanes,
  phases,
  initialTasks,
  overrideReason,
  generated,
  apiKey,
}) {
  /* ===== Core state ===== */
  const [laneList, setLaneList] = useState(
    Array.isArray(lanes) && lanes.length
      ? lanes.map((l, i) => ({
          name: l,
          color: LANE_PALETTE[i % LANE_PALETTE.length],
          visible: true,
          collapsed: false,
        }))
      : []
  );

  const [phaseList, setPhaseList] = useState(
    Array.isArray(phases) && phases.length
      ? phases.map((p) => ({ name: p, start: "", end: "" }))
      : []
  );

  const [tasks, setTasks] = useState(initialTasks || {});
  const [selectedTask, setSelectedTask] = useState(null);

  const [leftRail, setLeftRail] = useState(false);
  const [rightRail, setRightRail] = useState(false);
  const [activeLeftTab, setActiveLeftTab] = useState("workstreams");

  const [executiveMode, setExecutiveMode] = useState(false);

  /* ===== Ensure tasks shape matches lanes/phases ===== */
  function ensureTaskShape(baseTasks, lanesArr, phasesArr) {
    const out = deepClone(baseTasks || {});
    lanesArr.forEach((ln) => {
      if (!out[ln.name]) out[ln.name] = {};
      phasesArr.forEach((ph) => {
        if (!Array.isArray(out[ln.name][ph.name])) out[ln.name][ph.name] = [];
      });
    });
    // Remove lanes/phases that no longer exist (optional but keeps clean)
    Object.keys(out).forEach((laneName) => {
      if (!lanesArr.some((l) => l.name === laneName)) delete out[laneName];
      else {
        Object.keys(out[laneName]).forEach((phaseName) => {
          if (!phasesArr.some((p) => p.name === phaseName)) delete out[laneName][phaseName];
        });
      }
    });
    return out;
  }

  useEffect(() => {
    setTasks((p) => ensureTaskShape(p, laneList, phaseList));
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [laneList.length, phaseList.length]);

  /* ===== Dependency index + ID listing ===== */
  const allTaskIds = useMemo(() => {
    const ids = [];
    laneList.forEach((l) => {
      phaseList.forEach((p) => {
        const arr = tasks?.[l.name]?.[p.name] || [];
        arr.forEach((_, i) => ids.push(getTaskId(l.name, p.name, i)));
      });
    });
    return ids;
  }, [tasks, laneList, phaseList]);

  function getTaskById(id, t = tasks) {
    const { lane, phase, idx } = parseTaskId(id);
    return t?.[lane]?.[phase]?.[idx] || null;
  }

  function normalizeDependencies(t) {
    const index = buildDependencyIndex(t);
    Object.values(t).forEach((phasesObj) => {
      Object.values(phasesObj).forEach((arr) => {
        arr.forEach((task) => {
          task.blocks = Array.from(new Set((task.blocks || []).filter((id) => !!index[id])));
          task.blockedBy = Array.from(new Set((task.blockedBy || []).filter((id) => !!index[id])));
        });
      });
    });
    return t;
  }

  /* ===== Reindex IDs + remap dependencies (core integrity) ===== */
  function reindexAndRemap(baseTasks) {
    // 1) Build map oldId -> newId based on current iteration order
    const mapOldToNew = new Map();

    laneList.forEach((l) => {
      phaseList.forEach((p) => {
        const arr = baseTasks?.[l.name]?.[p.name] || [];
        arr.forEach((_, i) => {
          const oldId = getTaskId(l.name, p.name, i);
          // newId is same structure but will be recomputed after rebuild; for now identical
          // We'll rebuild arrays but keep same ordering => indices remain consistent per cell
          const newId = getTaskId(l.name, p.name, i);
          mapOldToNew.set(oldId, newId);
        });
      });
    });

    // 2) Rebuild tasks with clean deps remapped
    const out = ensureTaskShape({}, laneList, phaseList);

    laneList.forEach((l) => {
      phaseList.forEach((p) => {
        const arr = baseTasks?.[l.name]?.[p.name] || [];
        out[l.name][p.name] = arr.map((task) => ({
          label: task.label || "Untitled",
          status: task.status || "blue",
          detail: task.detail || "",
          owner: task.owner || "",
          blocks: (task.blocks || []).map((id) => mapOldToNew.get(id) || id),
          blockedBy: (task.blockedBy || []).map((id) => mapOldToNew.get(id) || id),
        }));
      });
    });

    return normalizeDependencies(out);
  }

  /* ===== Autosave ===== */
  useEffect(() => {
    const payload = {
      project,
      tier,
      lanes: laneList,
      phases: phaseList,
      tasks,
      overrideReason,
      generated,
      executiveMode,
      ui: { leftRail, rightRail, activeLeftTab },
      selectedTask,
      savedAt: new Date().toISOString(),
      version: 1,
    };
    localStorage.setItem("ocm_map_autosave", JSON.stringify(payload));
  }, [project, tier, laneList, phaseList, tasks, overrideReason, generated, executiveMode, leftRail, rightRail, activeLeftTab, selectedTask]);

  /* ===== Lane operations ===== */
  function addLane(name) {
    const n = String(name || "").trim();
    if (!n) return;
    if (laneList.some((l) => l.name === n)) return;

    const color = LANE_PALETTE[laneList.length % LANE_PALETTE.length];
    setLaneList((p) => [...p, { name: n, color, visible: true, collapsed: false }]);

    setTasks((p) => {
      const clone = deepClone(p);
      clone[n] = clone[n] || {};
      phaseList.forEach((ph) => (clone[n][ph.name] = clone[n][ph.name] || []));
      return normalizeDependencies(clone);
    });
  }

  function deleteLane(name) {
    if (!confirm(`Delete workstream "${name}"? This will delete its tasks.`)) return;

    // Remove lane and tasks
    setLaneList((p) => p.filter((l) => l.name !== name));

    setTasks((p) => {
      const clone = deepClone(p);
      delete clone[name];
      return normalizeDependencies(clone);
    });

    // Clear selection if it was in that lane
    if (selectedTask?.startsWith(`${name}||`)) setSelectedTask(null);
  }

  function renameLane(oldName, newName) {
    const nn = String(newName || "").trim();
    if (!nn || nn === oldName) return;
    if (laneList.some((l) => l.name === nn)) {
      alert("A workstream with that name already exists.");
      return;
    }

    // Update lane list
    setLaneList((p) => p.map((l) => (l.name === oldName ? { ...l, name: nn } : l)));

    // Remap tasks lane key + remap dependency IDs that include old lane name
    setTasks((p) => {
      const base = deepClone(p);
      base[nn] = base[oldName];
      delete base[oldName];

      // Replace IDs "oldLane||phase||idx" -> "newLane||phase||idx"
      Object.values(base).forEach((phasesObj) => {
        Object.values(phasesObj).forEach((arr) => {
          arr.forEach((t) => {
            t.blocks = (t.blocks || []).map((id) => (String(id).startsWith(`${oldName}||`) ? id.replace(`${oldName}||`, `${nn}||`) : id));
            t.blockedBy = (t.blockedBy || []).map((id) =>
              String(id).startsWith(`${oldName}||`) ? id.replace(`${oldName}||`, `${nn}||`) : id
            );
          });
        });
      });

      return normalizeDependencies(base);
    });

    // Update selected task id if applicable
    if (selectedTask && selectedTask.startsWith(`${oldName}||`)) {
      setSelectedTask(selectedTask.replace(`${oldName}||`, `${nn}||`));
    }
  }

  function toggleLaneVisibility(name) {
    setLaneList((p) => p.map((l) => (l.name === name ? { ...l, visible: !l.visible } : l)));
  }
  function toggleLaneCollapse(name) {
    setLaneList((p) => p.map((l) => (l.name === name ? { ...l, collapsed: !l.collapsed } : l)));
  }

  /* ===== Phase dates ===== */
  function updatePhaseDate(phaseName, field, value) {
    setPhaseList((p) => p.map((ph) => (ph.name === phaseName ? { ...ph, [field]: value } : ph)));
  }

  /* ===== Task operations ===== */
  function addTask(lane, phase) {
    setTasks((p) => {
      const clone = deepClone(p);
      clone[lane][phase].push({
        label: "New Task",
        status: "blue",
        detail: "",
        owner: "",
        blocks: [],
        blockedBy: [],
      });
      return normalizeDependencies(clone);
    });
  }

  function updateTask(lane, phase, index, updates) {
    setTasks((p) => {
      const clone = deepClone(p);
      clone[lane][phase][index] = { ...clone[lane][phase][index], ...updates };
      return normalizeDependencies(clone);
    });
  }

  function deleteTask(lane, phase, index) {
    setTasks((p) => {
      const base = deepClone(p);

      // Remove the task
      base[lane][phase].splice(index, 1);

      // After delete, IDs in this cell shift => we must remap dependencies
      // We do this by rebuilding a fresh ID map based on new indices.
      const rebuilt = reindexAndRemap(base);

      return rebuilt;
    });

    // Clear selection (safe)
    setSelectedTask(null);
  }

  /* ===== Dependency edit helpers (reciprocal) ===== */
  function linkDependency(fromId, toId, type) {
    // type: "blocks" means from blocks to; "blockedBy" means from is blocked by to
    if (!fromId || !toId || fromId === toId) return;

    setTasks((p) => {
      const clone = deepClone(p);
      const index = buildDependencyIndex(clone);
      const from = index[fromId];
      const to = index[toId];
      if (!from || !to) return clone;

      if (type === "blocks") {
        from.blocks = Array.from(new Set([...(from.blocks || []), toId]));
        to.blockedBy = Array.from(new Set([...(to.blockedBy || []), fromId]));
      } else {
        from.blockedBy = Array.from(new Set([...(from.blockedBy || []), toId]));
        to.blocks = Array.from(new Set([...(to.blocks || []), fromId]));
      }
      return normalizeDependencies(clone);
    });
  }

  function unlinkDependency(fromId, toId, type) {
    setTasks((p) => {
      const clone = deepClone(p);
      const index = buildDependencyIndex(clone);
      const from = index[fromId];
      const to = index[toId];
      if (!from || !to) return clone;

      if (type === "blocks") {
        from.blocks = (from.blocks || []).filter((id) => id !== toId);
        to.blockedBy = (to.blockedBy || []).filter((id) => id !== fromId);
      } else {
        from.blockedBy = (from.blockedBy || []).filter((id) => id !== toId);
        to.blocks = (to.blocks || []).filter((id) => id !== fromId);
      }
      return normalizeDependencies(clone);
    });
  }

  /* ===== Import / Export ===== */
  function exportJSON() {
    const data = {
      project,
      tier,
      lanes: laneList,
      phases: phaseList,
      tasks,
      overrideReason,
      generated,
      version: 1,
      exportedAt: new Date().toISOString(),
    };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${(project?.name || "ocm-map").replace(/[^\w\- ]+/g, "").trim() || "ocm-map"}.json`;
    a.click();
    URL.revokeObjectURL(url);
  }

  function importJSON(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const data = JSON.parse(e.target.result);

        const lanesIn = Array.isArray(data.lanes)
          ? data.lanes
          : (data.lanes || []).map((name, i) => ({
              name,
              color: LANE_PALETTE[i % LANE_PALETTE.length],
              visible: true,
              collapsed: false,
            }));

        const phasesIn = Array.isArray(data.phases)
          ? data.phases
          : (data.phases || []).map((name) => ({ name, start: "", end: "" }));

        setLaneList(lanesIn);
        setPhaseList(phasesIn);

        const shaped = ensureTaskShape(data.tasks || {}, lanesIn, phasesIn);
        setTasks(normalizeDependencies(shaped));
        setSelectedTask(null);
      } catch (err) {
        alert("Invalid JSON file.");
      }
    };
    reader.readAsText(file);
  }

  /* ===== Derived ===== */
  const visibleLanes = useMemo(() => laneList.filter((l) => l.visible), [laneList]);

  /* =========================================================
     UI components
     ========================================================= */

  function LeftSidebar() {
    const [newLane, setNewLane] = useState("");

    if (leftRail) {
      return (
        <div className="leftSide rail">
          <div className="leftRailIcon" onClick={() => setLeftRail(false)} title="Expand">
            ‚Ä∫
          </div>
        </div>
      );
    }

    return (
      <div className="leftSide">
        <div className="leftSideHeader">
          <strong>Controls</strong>
          <button className="btn btn-dark-ghost" onClick={() => setLeftRail(true)}>
            Collapse
          </button>
        </div>

        <div className="leftTabs">
          <button
            className="btn btn-dark-chip"
            style={{ flex: 1, background: activeLeftTab === "workstreams" ? "rgba(255,255,255,.08)" : "transparent" }}
            onClick={() => setActiveLeftTab("workstreams")}
          >
            Workstreams
          </button>
          <button
            className="btn btn-dark-chip"
            style={{ flex: 1, background: activeLeftTab === "dependencies" ? "rgba(255,255,255,.08)" : "transparent" }}
            onClick={() => setActiveLeftTab("dependencies")}
          >
            Dependencies
          </button>
        </div>

        <div style={{ flex: 1, overflow: "auto", padding: 12 }}>
          {activeLeftTab === "workstreams" && (
            <>
              {laneList.map((l) => (
                <div key={l.name} className="laneRow" style={{ borderLeftColor: l.color }}>
                  <div style={{ display: "flex", alignItems: "center", gap: 8, minWidth: 0 }}>
                    <input type="checkbox" className="chk" checked={l.visible} onChange={() => toggleLaneVisibility(l.name)} />
                    <span style={{ fontWeight: 800, overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" }}>{l.name}</span>
                  </div>
                  <div className="laneRowRight">
                    <button className="iconBtn danger" onClick={() => deleteLane(l.name)} title="Delete">
                      ‚úï
                    </button>
                  </div>
                </div>
              ))}

              <div style={{ marginTop: 14 }}>
                <input
                  className="inp"
                  placeholder="Add workstream"
                  value={newLane}
                  onChange={(e) => setNewLane(e.target.value)}
                  onKeyDown={(e) => {
                    if (e.key === "Enter") {
                      addLane(newLane);
                      setNewLane("");
                    }
                  }}
                />
              </div>
            </>
          )}

          {activeLeftTab === "dependencies" && (
            <>
              {!selectedTask && <div style={{ color: "#94a3b8", fontSize: 13 }}>Select a task to view its dependency chain.</div>}
              {selectedTask && (
                <>
                  <DependencyChain type="upstream" />
                  <DependencyChain type="selected" />
                  <DependencyChain type="downstream" />
                </>
              )}
            </>
          )}
        </div>
      </div>
    );
  }

  function DependencyChain({ type }) {
    const id = selectedTask;
    const upstream = getUpstreamChain(id, tasks);
    const downstream = getDownstreamChain(id, tasks);

    let list = [];
    let title = "";
    if (type === "upstream") {
      list = upstream;
      title = "Upstream";
    }
    if (type === "selected") {
      list = [id];
      title = "Selected";
    }
    if (type === "downstream") {
      list = downstream;
      title = "Downstream";
    }

    return (
      <div style={{ marginBottom: 16 }}>
        <div style={{ fontFamily: "var(--mono)", fontSize: 11, letterSpacing: ".08em", marginBottom: 6, color: "#94a3b8" }}>
          {title.toUpperCase()}
        </div>

        {list.length === 0 && type !== "selected" && <div style={{ fontSize: 13, color: "#64748b" }}>None</div>}

        {list.map((taskId) => {
          const t = getTaskById(taskId);
          if (!t) return null;
          const { lane, phase } = parseTaskId(taskId);
          return (
            <div
              key={taskId}
              style={{
                padding: "8px 10px",
                borderRadius: 10,
                background: "rgba(255,255,255,.06)",
                marginBottom: 6,
                cursor: "pointer",
              }}
              onClick={() => setSelectedTask(taskId)}
            >
              <div style={{ fontWeight: 800, fontSize: 13 }}>{t.label}</div>
              <div style={{ fontSize: 11, color: "#94a3b8" }}>
                {lane} ¬∑ {phase}
              </div>
            </div>
          );
        })}
      </div>
    );
  }

  function PhaseHeader({ phase, index }) {
    const [open, setOpen] = useState(false);
    const popRef = useRef(null);

    useEffect(() => {
      function onDoc(e) {
        if (!open) return;
        if (popRef.current && !popRef.current.contains(e.target)) setOpen(false);
      }
      document.addEventListener("mousedown", onDoc);
      return () => document.removeEventListener("mousedown", onDoc);
    }, [open]);

    return (
      <div className="phaseHeaderCell">
        <div className="card" style={{ padding: 10, position: "relative" }}>
          <div style={{ fontFamily: "var(--mono)", fontSize: 11, letterSpacing: ".08em", color: "#94a3b8" }}>PHASE</div>
          <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", gap: 8 }}>
            <strong style={{ overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" }}>{phase.name}</strong>
            {!executiveMode && (
              <button className="iconBtn" onClick={() => setOpen((o) => !o)} title="Edit phase dates">
                üìÖ
              </button>
            )}
          </div>

          {!executiveMode && open && (
            <div className="pop" ref={popRef}>
              <label className="lbl">Start date</label>
              <input type="date" className="inp" value={phase.start} onChange={(e) => updatePhaseDate(phase.name, "start", e.target.value)} />
              <label className="lbl" style={{ marginTop: 10 }}>
                End date
              </label>
              <input type="date" className="inp" value={phase.end} onChange={(e) => updatePhaseDate(phase.name, "end", e.target.value)} />
            </div>
          )}
        </div>
      </div>
    );
  }

  function TaskCard({ lane, phase, task, index }) {
    const meta = STATUS_META[task.status] || STATUS_META.blue;
    return (
      <div className="taskCard" onClick={() => setSelectedTask(getTaskId(lane, phase, index))}>
        <div className="taskBorder" style={{ background: meta.color }} />
        <div className="taskInner">
          <div className="taskTitle">{task.label}</div>
          <div className="taskMeta">
            {meta.label}
            {task.owner ? ` ¬∑ ${task.owner}` : ""}
          </div>
        </div>
      </div>
    );
  }

  function Drawer() {
    if (executiveMode) return null;

    if (rightRail) {
      return (
        <div className="drawer rail">
          <div className="leftRailIcon" onClick={() => setRightRail(false)} title="Expand">
            ‚Äπ
          </div>
        </div>
      );
    }

    if (!selectedTask) {
      return (
        <div className="drawer">
          <div className="drawerHeader">
            <strong>Task Details</strong>
            <button className="btn btn-secondary" onClick={() => setRightRail(true)}>
              Collapse
            </button>
          </div>
          <div className="drawerBody" style={{ color: "#64748b" }}>
            Select a task to edit.
          </div>
        </div>
      );
    }

    const { lane, phase, idx } = parseTaskId(selectedTask);
    const task = tasks?.[lane]?.[phase]?.[idx];
    if (!task) return null;

    const candidates = allTaskIds.filter((id) => id !== selectedTask);

    return (
      <div className="drawer">
        <div className="drawerHeader">
          <strong>Edit Task</strong>
          <button className="btn btn-secondary" onClick={() => setRightRail(true)}>
            Collapse
          </button>
        </div>

        <div className="drawerBody">
          <label className="lbl">Title</label>
          <input className="inp" value={task.label} onChange={(e) => updateTask(lane, phase, idx, { label: e.target.value })} />

          <label className="lbl" style={{ marginTop: 12 }}>
            Owner
          </label>
          <input className="inp" value={task.owner} onChange={(e) => updateTask(lane, phase, idx, { owner: e.target.value })} />

          <label className="lbl" style={{ marginTop: 12 }}>
            Status
          </label>
          <select className="inp" value={task.status} onChange={(e) => updateTask(lane, phase, idx, { status: e.target.value })}>
            {Object.keys(STATUS_META).map((k) => (
              <option key={k} value={k}>
                {STATUS_META[k].label}
              </option>
            ))}
          </select>

          <label className="lbl" style={{ marginTop: 12 }}>
            Detail
          </label>
          <textarea className="inp" value={task.detail} onChange={(e) => updateTask(lane, phase, idx, { detail: e.target.value })} />

          {/* Dependencies */}
          <div style={{ marginTop: 14 }} className="card">
            <div style={{ padding: 12 }}>
              <div className="lbl" style={{ marginBottom: 10 }}>
                Dependencies
              </div>

              <div style={{ display: "grid", gridTemplateColumns: "1fr", gap: 10 }}>
                <div>
                  <div style={{ fontFamily: "var(--mono)", fontSize: 11, fontWeight: 900, color: "#64748b", marginBottom: 6 }}>
                    BLOCKED BY
                  </div>
                  {(task.blockedBy || []).length === 0 ? (
                    <div style={{ fontSize: 13, color: "#64748b" }}>None</div>
                  ) : (
                    (task.blockedBy || []).map((id) => {
                      const t2 = getTaskById(id);
                      if (!t2) return null;
                      const loc = parseTaskId(id);
                      return (
                        <div key={id} style={{ display: "flex", alignItems: "center", justifyContent: "space-between", gap: 8, padding: "8px 10px", borderRadius: 12, background: "#fff", border: "1px solid var(--border)", marginBottom: 6 }}>
                          <div style={{ minWidth: 0, cursor: "pointer" }} onClick={() => setSelectedTask(id)} title="Go to task">
                            <div style={{ fontWeight: 900, fontSize: 13, overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" }}>{t2.label}</div>
                            <div style={{ fontSize: 11, color: "#64748b" }}>
                              {loc.lane} ¬∑ {loc.phase}
                            </div>
                          </div>
                          <button className="iconBtn danger" title="Remove" onClick={() => unlinkDependency(selectedTask, id, "blockedBy")}>
                            ‚úï
                          </button>
                        </div>
                      );
                    })
                  )}

                  <select
                    className="inp"
                    value=""
                    onChange={(e) => {
                      const id = e.target.value;
                      if (!id) return;
                      linkDependency(selectedTask, id, "blockedBy");
                      e.target.value = "";
                    }}
                  >
                    <option value="">+ Add blocker‚Ä¶</option>
                    {candidates.map((id) => {
                      const t2 = getTaskById(id);
                      if (!t2) return null;
                      const loc = parseTaskId(id);
                      return (
                        <option key={id} value={id}>
                          {t2.label} ‚Äî {loc.lane} / {loc.phase}
                        </option>
                      );
                    })}
                  </select>
                </div>

                <div>
                  <div style={{ fontFamily: "var(--mono)", fontSize: 11, fontWeight: 900, color: "#64748b", marginBottom: 6 }}>
                    BLOCKS
                  </div>
                  {(task.blocks || []).length === 0 ? (
                    <div style={{ fontSize: 13, color: "#64748b" }}>None</div>
                  ) : (
                    (task.blocks || []).map((id) => {
                      const t2 = getTaskById(id);
                      if (!t2) return null;
                      const loc = parseTaskId(id);
                      return (
                        <div key={id} style={{ display: "flex", alignItems: "center", justifyContent: "space-between", gap: 8, padding: "8px 10px", borderRadius: 12, background: "#fff", border: "1px solid var(--border)", marginBottom: 6 }}>
                          <div style={{ minWidth: 0, cursor: "pointer" }} onClick={() => setSelectedTask(id)} title="Go to task">
                            <div style={{ fontWeight: 900, fontSize: 13, overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" }}>{t2.label}</div>
                            <div style={{ fontSize: 11, color: "#64748b" }}>
                              {loc.lane} ¬∑ {loc.phase}
                            </div>
                          </div>
                          <button className="iconBtn danger" title="Remove" onClick={() => unlinkDependency(selectedTask, id, "blocks")}>
                            ‚úï
                          </button>
                        </div>
                      );
                    })
                  )}

                  <select
                    className="inp"
                    value=""
                    onChange={(e) => {
                      const id = e.target.value;
                      if (!id) return;
                      linkDependency(selectedTask, id, "blocks");
                      e.target.value = "";
                    }}
                  >
                    <option value="">+ Add blocked task‚Ä¶</option>
                    {candidates.map((id) => {
                      const t2 = getTaskById(id);
                      if (!t2) return null;
                      const loc = parseTaskId(id);
                      return (
                        <option key={id} value={id}>
                          {t2.label} ‚Äî {loc.lane} / {loc.phase}
                        </option>
                      );
                    })}
                  </select>
                </div>
              </div>
            </div>
          </div>

          <div style={{ marginTop: 14, display: "flex", gap: 10 }}>
            <button className="btn btn-danger" onClick={() => deleteTask(lane, phase, idx)}>
              Delete Task
            </button>
            <button className="btn btn-secondary" onClick={() => setSelectedTask(null)}>
              Close
            </button>
          </div>
        </div>
      </div>
    );
  }

  function LaneHeader({ laneObj }) {
    const [editing, setEditing] = useState(false);
    const [draft, setDraft] = useState(laneObj.name);

    useEffect(() => setDraft(laneObj.name), [laneObj.name]);

    return (
      <div className="laneHeaderCell card laneTile">
        <div className="laneBar" style={{ background: laneObj.color }} />
        <div style={{ minWidth: 0 }}>
          {!editing ? (
            <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
              <div style={{ fontWeight: 900, overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" }}>{laneObj.name}</div>
              <button className="iconBtn" title="Rename" onClick={() => setEditing(true)}>
                ‚úé
              </button>
            </div>
          ) : (
            <div style={{ display: "flex", gap: 8, alignItems: "center" }}>
              <input
                className="inp"
                style={{ padding: "8px 10px", height: 34 }}
                value={draft}
                autoFocus
                onChange={(e) => setDraft(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === "Enter") {
                    renameLane(laneObj.name, draft);
                    setEditing(false);
                  }
                  if (e.key === "Escape") {
                    setDraft(laneObj.name);
                    setEditing(false);
                  }
                }}
              />
              <button
                className="iconBtn"
                title="Save"
                onClick={() => {
                  renameLane(laneObj.name, draft);
                  setEditing(false);
                }}
              >
                ‚úì
              </button>
            </div>
          )}
        </div>

        <button className="iconBtn" onClick={() => toggleLaneCollapse(laneObj.name)} title="Collapse/Expand lane">
          {laneObj.collapsed ? "+" : "‚Äì"}
        </button>
      </div>
    );
  }

  function Grid() {
    return (
      <div className="mainArea">
        <div style={{ padding: "10px 14px", display: "flex", justifyContent: "space-between", alignItems: "center", gap: 10 }}>
          <div style={{ minWidth: 0 }}>
            <strong style={{ display: "inline-block", maxWidth: 520, overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" }}>
              {project?.name || "OCM Readiness Map"}
            </strong>
            <span style={{ marginLeft: 10, color: "#64748b" }}>{TIER_CFG[tier]?.label || ""}</span>
          </div>

          <div style={{ display: "flex", gap: 8, flexWrap: "wrap", justifyContent: "flex-end" }}>
            <button className="btn btn-secondary" onClick={() => setExecutiveMode((e) => !e)}>
              {executiveMode ? "Exit Executive View" : "Executive View"}
            </button>
            <button className="btn btn-secondary" onClick={exportJSON}>
              Export
            </button>
            <label className="btn btn-secondary">
              Import
              <input type="file" accept=".json" style={{ display: "none" }} onChange={(e) => importJSON(e.target.files?.[0])} />
            </label>
          </div>
        </div>

        <div className="gridWrap">
          <div className="mapGrid" style={{ gridTemplateColumns: `260px repeat(${phaseList.length}, minmax(260px,1fr))` }}>
            {/* Header Row */}
            <div className="laneHeaderCell card" style={{ padding: 10, fontWeight: 900 }}>
              Workstream
            </div>

            {phaseList.map((p, i) => (
              <PhaseHeader key={p.name} phase={p} index={i} />
            ))}

            {/* Rows */}
            {visibleLanes.map((l) => (
              <React.Fragment key={l.name}>
                <LaneHeader laneObj={l} />

                {phaseList.map((p, pi) => (
                  <div key={p.name} className={`phaseCell ${pi % 2 === 1 ? "phaseStripe" : ""}`} style={{ padding: 6 }}>
                    {!l.collapsed && (
                      <>
                        {(tasks?.[l.name]?.[p.name] || []).map((t, i) => (
                          <div key={i} style={{ marginBottom: 8 }}>
                            <TaskCard lane={l.name} phase={p.name} task={t} index={i} />
                          </div>
                        ))}
                        <button className="btn btn-ghost" style={{ marginTop: 2 }} onClick={() => addTask(l.name, p.name)}>
                          + Add Task
                        </button>
                      </>
                    )}
                  </div>
                ))}
              </React.Fragment>
            ))}
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="stage4Shell">
      <LeftSidebar />
      <Grid />
      <Drawer />
    </div>
  );
}

/* =========================================================
   App Root (Stages 1‚Äì4 + Autosave Restore)
   ========================================================= */

function App(){
  const [stage,setStage] = useState(0);
  const [apiKey,setApiKey] = useState(localStorage.getItem("anthropic_key") || "");

  const [project,setProject] = useState({name:"",owner:"",date:"",description:""});
  const [scores,setScores] = useState(null);
  const [suggestedTier,setSuggestedTier] = useState(2);

  const [tier,setTier] = useState(2);
  const [lanes,setLanes] = useState([]);
  const [phases,setPhases] = useState([]);
  const [tasks,setTasks] = useState({});
  const [overrideReason,setOverrideReason] = useState("");
  const [generated,setGenerated] = useState(false);

  /* Restore autosave on load */
  useEffect(()=>{
    try{
      const raw = localStorage.getItem("ocm_map_autosave");
      if(!raw) return;
      const data = JSON.parse(raw);

      if(data?.project?.name || data?.tasks){
        setProject(data.project || project);
        setTier(data.tier || 2);
        setSuggestedTier(data.tier || 2);
        // lanes/phases may be saved as objects (v1) ‚Äî Stage4Fixed accepts lanes as array of names for props,
        // but we pass names arrays here and Stage4Fixed uses them to initialize laneList/phaseList.
        const laneNames = Array.isArray(data.lanes) ? data.lanes.map(l=>l.name || l).filter(Boolean) : [];
        const phaseNames = Array.isArray(data.phases) ? data.phases.map(p=>p.name || p).filter(Boolean) : [];
        setLanes(laneNames);
        setPhases(phaseNames);
        setTasks(data.tasks || {});
        setOverrideReason(data.overrideReason || "");
        setGenerated(!!data.generated);
        setStage(3);
      }
    }catch(_){}
    // eslint-disable-next-line react-hooks/exhaustive-deps
  },[]);

  useEffect(()=>{
    localStorage.setItem("anthropic_key", apiKey);
  },[apiKey]);

  function resetAll(){
    if(!confirm("Reset and clear autosave?")) return;
    localStorage.removeItem("ocm_map_autosave");
    setStage(0);
    setProject({name:"",owner:"",date:"",description:""});
    setScores(null);
    setSuggestedTier(2);
    setTier(2);
    setLanes([]);
    setPhases([]);
    setTasks({});
    setOverrideReason("");
    setGenerated(false);
  }

  return(
    <div style={{height:"100%",display:"flex",flexDirection:"column",minHeight:0}}>
      {/* Top Bar */}
      <div className="appTopBar">
        <div style={{display:"flex",alignItems:"center",gap:10,minWidth:0}}>
          <div style={{fontFamily:"var(--serif)",fontSize:18,fontWeight:700,whiteSpace:"nowrap"}}>OCM Readiness Map Builder</div>
          <span className="subtle" style={{fontFamily:"var(--mono)",fontSize:12,letterSpacing:".06em"}}>SINGLE-FILE ¬∑ LOCAL</span>
        </div>

        <div style={{display:"flex",alignItems:"center",gap:10,flexWrap:"wrap",justifyContent:"flex-end"}}>
          <div style={{display:"flex",alignItems:"center",gap:8}}>
            <span className="subtle" style={{fontFamily:"var(--mono)",fontSize:12}}>Anthropic Key</span>
            <input
              className="inp"
              style={{width:260,padding:"8px 10px",height:36}}
              placeholder="sk-ant-‚Ä¶"
              value={apiKey}
              onChange={e=>setApiKey(e.target.value)}
            />
          </div>

          <button className="btn btn-dark-ghost" onClick={()=>{ClickAudio.click(); resetAll();}}>
            Reset
          </button>
        </div>
      </div>

      {/* Body */}
      <div style={{flex:1,minHeight:0,overflow:"auto",padding:18}}>
        {stage < 3 && (
          <div style={{maxWidth:980,margin:"0 auto"}}>
            <Steps current={stage}/>
            <div className="card" style={{padding:18}}>
              {stage===0 && (
                <Stage1 onNext={(proj)=>{
                  setProject(proj);
                  setStage(1);
                }}/>
              )}
              {stage===1 && (
                <Stage2
                  project={project}
                  onNext={(sc,t)=>{
                    setScores(sc);
                    setSuggestedTier(t);
                    setStage(2);
                  }}
                />
              )}
              {stage===2 && (
                <Stage3
                  project={project}
                  suggestedTier={suggestedTier}
                  apiKey={apiKey}
                  onNext={(tierPicked, laneArr, phaseArr, tasksObj, override, wasGenerated)=>{
                    setTier(tierPicked);
                    setLanes(laneArr);
                    setPhases(phaseArr);
                    setTasks(tasksObj);
                    setOverrideReason(override || "");
                    setGenerated(!!wasGenerated);
                    setStage(3);
                  }}
                />
              )}
            </div>
          </div>
        )}

        {stage===3 && (
          <div style={{height:"calc(100vh - 92px)",minHeight:520}}>
            <Stage4Fixed
              project={project}
              tier={tier}
              lanes={lanes}
              phases={phases}
              initialTasks={tasks}
              overrideReason={overrideReason}
              generated={generated}
              apiKey={apiKey}
            />
          </div>
        )}
      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById("root")).render(<App/>);
</script>

</body>
</html>